# 유나: 풍선팡 피드백

### 1. 역질문

주석에 `델타를 따라서 한 칸씩 K만큼 멀리 감 -> 곱하기` 라고 깨달음을 얻은 과정을 잘 적어주셨습니다. 

만약 여기서 `곱하기 far` 부분이 없다면, `r + dr[i]` 코드는 어떤 역할만 수행하게 될까요? 

`far` 변수가 델타 탐색을 '한 칸'에서 '**여러 칸**'으로 확장시키는 핵심 키라는 점을 잘 이해하고 있는지 확인해보고 싶습니다.

-> 상하좌우 한 칸만 확인할 것입니다. 

------

### 2. 단계별 피드백

- **고민의 과정과 해결**
  
  - "막힌 부분 1"에 대한 고민은 델타 탐색을 처음 배우는 학생들이 가장 흔하게 겪는 어려움입니다. `dr = [-1, 1, 0, 0]` 과 같은 델타 배열은 그 자체로 '한 칸'의 이동만을 의미하기 때문입니다.
  - 여기서 `for far in range(1, k + 1)` 라는 반복문을 추가하여 '이동'을 '반복'하고, `dr[i] * far` 와 같이 거리를 곱해주는 방식으로 문제를 해결한 것은 이해를 잘 한 것으로 보입니다.

- **코드 구조**
  
  - `for r, c in ...`: 모든 풍선을 순회하는 바깥쪽 루프.
  - `for i in range(4):`: 4개의 방향을 결정하는 중간 루프.
  - `for far in range(1, k + 1):`: 정해진 방향으로 `k`칸 만큼 나아가는 안쪽 루프.
  - 이 3중 반복문 구조는 2차원 배열에서 특정 지점을 기준으로 확장 탐색을 할 때 가장 기본이 되는 구조입니다.

- **최댓값 갱신**
  
  - 하나의 풍선 `(r, c)`에 대한 총합 `result` 계산이 모두 끝난 후에 `if answer < result:`를 통해 최댓값을 갱신하는 로직 또한 정확한 위치에 작성되었습니다.

------

### 3. 기계적인 코딩 개선

 **'델타 탐색의 확장'** 패턴을 조금 더 개념적으로 이해해 본다면, `(dr[i], dc[i])`는 '길이가 1인 방향 벡터'라고 볼 수 있습니다. 

여기에 `far`라는 스칼라 값을 곱함으로써, 우리는 이 벡터의 크기를 `1, 2, 3, ..., k`로 점차 늘려나가는 것입니다. 이렇게 기본 패턴을 더 일반적인 개념과 연결해두면, 나중에 더 복잡한 이동(예: 대각선, 나선형 등)이 필요한 문제가 나와도 당황하지 않고 원리를 응용하여 해결할 수 있습니다.

------

### 4. 스타일 가이드

- **변수명:** `arr`보다는 `grid`, `k`보다는 `power` 또는 `distance`와 같이 변수의 역할을 명확히 드러내는 이름을 사용하는 것이 좋습니다. `far`는 거리를 의미하는 좋은 변수명입니다. `answer`와 `result`도 역할이 명확하여 좋습니다.

------

### 5. 이 문제의 핵심

- **기본 델타 탐색을 응용하여, 특정 값만큼 여러 칸을 탐색하는 방법**
- `for` 반복문을 중첩하고 방향 벡터에 거리를 곱해주는 이 패턴은 2차원 배열 탐색 문제에서 매우 유용하므로 반드시 기억해야 합니다.

------

### 6. 역질문에 대한 해설

만약 `* far` 부분이 없다면, `r + dr[i]` 코드는 `k`값에 상관없이 항상 현재 위치 `r`의 **정확히 한 칸 위**(`dr[0]`), **한 칸 아래**(`dr[1]`) 등 인접한 한 칸의 위치만을 계산하게 됩니다. `for far...` 반복문이 있더라도 매번 똑같은 한 칸짜리 이동만 반복하게 될 것입니다.

`far` 변수는 이 '한 칸짜리 기본 이동'을 **'두 칸', '세 칸', ..., 'k 칸'** 으로 확장시켜주는 **'척도(scale)'** 역할을 합니다. 따라서 이 `곱하기` 연산이야말로 델타 탐색을 한 단계 응용하는 핵심적인 부분이라고 할 수 있습니다. 이 핵심을 정확히 파악하고 잘 구현했습니다.