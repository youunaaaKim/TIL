# 유나: 포탈 피드백

 `for`문과 `while`문의 차이점을 고민하고, 문제에 더 적합한 `while`문을 선택한 것은 문제를 잘 파악했다고 봅니다.

------

### 1. 역질문

1번 방에서 출발할 때, 포탈을 딱 한 번 사용하면 현재 위치는 2번 방이 되고, `count`는 1이 되어야 합니다. 유나님의 코드에서 `while`문이 처음 한 바퀴 돌았을 때, `where_am_i`와 `count`의 최종 값은 각각 무엇이 될까요? `if`문 세 개가 순서대로 모두 확인된다는 점을 생각하며 코드를 한 줄씩 따라가 보면 원인을 찾는 데 도움이 될 것 같습니다.

------

### 2. 단계별 피드백

- **고의 흔적 (주석)**
  
  - "막혔던 부분 1": `for`문은 정해진 횟수만큼 순차적으로 반복할 때 사용합니다. 이 문제처럼 **특정 조건(N번 방 도착)이 만족될 때까지 비선형적으로 이동하는 경우는 `while`문을 사용하는 것**이 맞습니다. 
  - "막혔던 부분 2": 1번 방의 로직을 `while`문 안에 배치한 것은 올바른 결정입니다. 게임이 진행되는 동안 `where_am_i`는 언제든 1이 될 수 있으므로, 반복문 안에서 계속 확인하는 것이 안전합니다.

- **`while`문 내부 로직: 제어 흐름의 오류**
  
  - 코드의 핵심적인 개선점은 세 개의 `if`문을 사용한 방식에 있습니다.
  - **`if where_am_i == 1:`**
  - **`if visit[where_am_i] == 0:`**
  - **`if visit[where_am_i] == 1:`**
  - 이 세 가지 조건은 **'1번 방에 있는 경우'**, **'처음 방문한 방인 경우'**, **'재방문한 방인 경우'**를 나타냅니다. 이들은 동시에 일어날 수 없는, 즉 **상호 배타적인** 관계입니다.
  - 하지만 코드는 세 개의 `if`문이 독립적으로 연달아 배치되어 있습니다. 이렇게 되면, 첫 번째 `if`문이 실행된 후에도 프로그램은 멈추지 않고 두 번째, 세 번째 `if`문을 순서대로 계속 검사하게 됩니다.
  - 이로 인해 포탈을 한 번만 타야 하는 논리적 단위에서 코드는 여러 번의 이동과 카운트 증가를 수행하는 오류를 일으킵니다.
  - 이처럼 여러 선택지 중 단 하나만 실행되어야 하는 경우에는 `if - elif - else` 구조를 사용해야 합니다.

------

### 3. 기계적인 코딩 개선

이번 코드에서 발견된 실수는 **'논리적 제어 흐름'**을 코드로 구현하는 과정에서 자주 발생하는 유형입니다. `"1번 방이면 오른쪽으로 간다. 그렇지 않고, 만약 처음 방문이면 왼쪽으로 간다. 그것도 아니면 오른쪽으로 간다."` 와 같은 문제의 문장을 코드로 그대로 옮기는 연습이 필요합니다.

- `if ...:` -> "...이면"
- `elif ...:` -> "그렇지 않고, 만약 ...이면"
- `else:` -> "그것도 아니면"

이처럼 한국어 문장 구조와 제어문의 역할을 연결해서 생각하면, 논리적 흐름을 코드로 옮길 때 실수를 크게 줄일 수 있습니다. 앞으로는 코드를 작성하기 전에 문제의 조건들을 위와 같은 문장으로 먼저 만들어보는 습관을 들이는 것을 추천합니다.

------

### 4. 스타일 가이드

- **변수명:** `arr`는 배열을 의미하는 일반적인 이름입니다. `portals` 또는 `left_portal_info`처럼 데이터의 의미를 담아 작성하면 코드를 이해하기 훨씬 수월합니다. `where_am_i`는 의미가 명확하지만, `current_room`과 같이 조금 더 간결한 이름도 좋습니다.
- **Boolean 표현:** `visit` 배열의 값을 `0`과 `1`로 사용하는 것도 좋지만, 파이썬에서는 `False`와 `True`라는 `Boolean` 타입을 사용하는 것이 일반적입니다. `if visit[current_room] == 0:` 보다는 `if not visited[current_room]:` 와 같이 작성하면 **'방문하지 않았다면'**이라는 의미가 더 명확하게 드러납니다.

------

### 5. 이 문제의 핵심

- 문제의 조건을 코드로 옮길 때 정확한 제어문(`if-elif-else`)을 선택하는 것
- 'A인 경우', 'A가 아니고 B인 경우', 'A와 B 둘 다 아닌 경우'처럼 **상호 배타적인 조건들은 반드시 `if-elif-else`로 묶어줘야** 의도한 대로 동작합니다.

------

### 6. 역질문에 대한 해설

역질문에 대한 답을 코드로 직접 따라가 보면 다음과 같습니다.

- **초기 상태:** `where_am_i = 1`, `count = 0`
- **`while`문 첫 반복 시작:**
  1. **`if where_am_i == 1:`** 이 참이므로 실행됩니다.
     - `where_am_i`는 `2`가 됩니다.
     - `count`는 `1`이 됩니다.
     - `visit[1]`은 `1`이 됩니다.
  2. **`if visit[where_am_i] == 0:`** 즉, `if visit[2] == 0:` 을 검사합니다. 참이므로 실행됩니다.
     - `visit[2]`는 `1`이 됩니다.
     - `where_am_i`는 `arr[1]`의 값으로 바뀝니다. (예시 입력에서는 `1`)
     - `count`는 `2`가 됩니다.
  3. **`if visit[where_am_i] == 1:`** 즉, `if visit[1] == 1:` 을 검사합니다. 참이므로 실행됩니다.
     - `where_am_i`는 `1 + 1` 이 되어 `2`가 됩니다.
     - `count`는 `3`이 됩니다.
- **`while`문 첫 반복 종료:** 최종적으로 `where_am_i`는 `2`, `count`는 `3`이 됩니다.

단 한 번의 이동이었지만, `count`는 3번이나 증가하고 `where_am_i` 값도 여러 번 바뀌는 것을 볼 수 있습니다. `if-elif-else`를 사용하면 `if where_am_i == 1:` 블록이 실행된 후 나머지 `elif`와 `else`는 건너뛰므로 이러한 문제가 해결됩니다.